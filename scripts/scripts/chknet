#!/bin/python

import os
import json
import subprocess
import shlex
import sys
import re


class host:
    def __init__(self, hostname, checks, name=None):
        self.hostname = hostname
        self.checks = checks

        if name is None:
            self.name = hostname
        else:
            self.name = name

    def __repr__(self):
        return "{} (): {}".format(self.hostname, self.name, self.checks)


class check:
    def __init__(self, command, returncode=None, output=None, name=None):
        self.command = command
        self.returncode = returncode
        self.output = output

        if name is None:
            self.name = shlex.split(command)[0]
        else:
            self.name = name

        if returncode is None:
            self.returncode = 0
        else:
            self.returncode = returncode

    def __str__(self):
        return self.command

    def __repr__(self):
        return str(self)

def runcommand(cmd, host):

    if cmd.startswith("$"):
        cmd = cmd[1:].strip()
        try:
            cmd = cmd.replace("<hostname>", host.hostname)
            cmd = shlex.split(cmd)
            out = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            output = out
            returncode = 0
        except subprocess.CalledProcessError as e:
            output = e.output
            returncode = e.returncode

        output = output.decode("UTF8").strip()
        return (output, returncode)
    elif cmd.startswith("%"):
        cmd = cmd[1:].strip()
        
    else:
        sys.stderr.write("\nINVALID COMMAND TYPE\n")
        sys.exit(1)

def readhosts(path):
    try:
        blob = json.load(open(dpath, "r"))
    except FileNotFoundError:
        blob = []

        json.dump([], open(dpath, "w"))

    hosts = []

    for hostdict in blob:
        hostname = hostdict["hostname"]
        name = None
        try:
            name = hostdict["name"]
        except KeyError:
            pass

        checks = []
        for chk in hostdict["checks"]:
            command = chk["command"]
            returncode = None
            output = None
            chkname = None

            try:
                returncode = chk["returncode"]
            except KeyError:
                pass

            try:
                output = chk["output"]
            except KeyError:
                pass

            try:
                chkname = chk["name"]
            except KeyError:
                pass

            checks.append(check(command, returncode, output, chkname))

        h = host(hostname, checks, name)
        hosts.append(h)

    return hosts

dpath = os.path.expanduser("~/scripts/data/chknet.json")
hosts = readhosts(dpath)

for host in hosts:
    numchecks = len(host.checks)
    passedchecks = 0

    print("{}: {} check{}".format(host.name,
                                  numchecks,
                                  "s" if numchecks > 1 else ""
                                  ))

    for check in host.checks:
        passed = True

        output, returncode = runcommand(check.command, host)

        if check.output is not None:
            if check.output != output:
                if not re.fullmatch(check.output, output, re.MULTILINE):
                    passed = False
                    print("{} did not match {}".format(check.output, output))

        if check.returncode is not None:
            if check.returncode != returncode:
                passed = False

        if passed:
            passedchecks += 1
            print("\t\x1b[32m{}\x1b[m".format(check.name))
        else:
            print("\t\x1b[31m{}\x1b[m".format(check.name))

    print("")
